<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Development Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #111827;
            color: #d1d5db;
        }
        .tab-button {
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
        }
        iframe {
            width: 100%;
            height: 80vh;
            border: none;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white">Kevin Evans</h1>
            <h1 class="text-4xl md:text-5xl font-bold text-white">My Interactive Projects</h1>
            <p class="text-lg text-gray-400 mt-2">Click a tab to load a game</p>
        </header>

        <!-- Tabs Navigation -->
        <nav class="flex justify-center flex-wrap gap-2 sm:gap-4 mb-8" id="tabs">
            <button class="tab-button active text-sm sm:text-base font-semibold py-2 px-4 rounded-full bg-gray-700 hover:bg-gray-600" data-game="taxPlinkov2">Tax Plinko</button>
            <button class="tab-button text-sm sm:text-base font-semibold py-2 px-4 rounded-full bg-gray-700 hover:bg-gray-600" data-game="farmRace">Farm Race</button>
            <button class="tab-button text-sm sm:text-base font-semibold py-2 px-4 rounded-full bg-gray-700 hover:bg-gray-600" data-game="collector">Collector Game</button>
            <button class="tab-button text-sm sm:text-base font-semibold py-2 px-4 rounded-full bg-gray-700 hover:bg-gray-600" data-game="taxPlinkov1">Tax Plinko (Classic)</button>
        </nav>

        <!-- Game Display Area -->
        <main class="bg-gray-900 p-2 rounded-lg shadow-2xl">
            <iframe id="game-frame"></iframe>
        </main>

        <footer class="text-center mt-8 text-gray-500">
            <p>&copy; 2025 Kevin Evans. All Rights Reserved.</p>
        </footer>
    </div>

    <script>
        // --- Game Content ---
        // The full HTML content of each game is stored here.
        const gameContent = {
            taxPlinkov2: `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wall - Plinko Trivia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"><\/script>
    <script src="https://cdn.tailwindcss.com"><\/script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 500px;
            margin: 1rem;
        }
        canvas {
            background-color: #4a5568;
            border-radius: 1rem;
            width: 100%;
            height: 640px; /* Fixed height for the viewport */
            cursor: pointer;
        }
        .controls-area {
            width: 100%;
            text-align: center;
            margin-top: 1.5rem;
        }
        /* Trivia Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .answer-btn {
            display: block;
            width: 100%;
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-radius: 0.5rem;
            border: 2px solid #718096;
            background-color: #4a5568;
            color: #e2e8f0;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .answer-btn:hover:not(:disabled) {
            background-color: #718096;
        }
        .answer-btn.correct { background-color: #48bb78; border-color: #68d391; }
        .answer-btn.incorrect { background-color: #f56565; border-color: #fc8181; }
        .answer-btn:disabled { cursor: not-allowed; opacity: 0.7; }

        #result-message { font-size: 1.5rem; font-weight: bold; margin-top: 1rem; height: 2rem; }
        .correct-text { color: #68d391; }
        .incorrect-text { color: #fc8181; }

        .action-button {
            background: linear-gradient(145deg, #4299e1, #3182ce);
            color: white;
            border: none;
            border-radius: 0.75rem;
            padding: 1rem 2.5rem;
            font-size: 1.25rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 15px -3px rgba(66, 153, 225, 0.3), 0 4px 6px -2px rgba(66, 153, 225, 0.2);
            transition: all 0.2s ease-in-out;
        }
        .super-drop-button {
             background: linear-gradient(145deg, #f87171, #ef4444);
        }
        .instruction-text {
            color: #a0aec0;
            height: 2rem;
            margin-bottom: 1rem;
            font-style: italic;
        }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="plinko-canvas"></canvas>
    <div class="controls-area">
        <div id="instruction-text" class="instruction-text"></div>
        <button id="start-round-button" class="action-button">Start New Game</button>
    </div>
</div>

<!-- Trivia Modal -->
<div id="trivia-modal" class="modal-overlay">
    <div class="modal-content">
        <h2 id="question-text" class="text-2xl mb-4">Question text will go here.</h2>
        <div id="answer-buttons"></div>
        <p id="result-message"></p>
        <button id="close-modal-button" class="action-button" style="display: none;">See the Drop!</button>
    </div>
</div>

<script>
    // --- Matter.js Aliases ---
    const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Mouse, MouseConstraint, Query } = Matter;

    // --- Game Setup ---
    const canvas = document.getElementById('plinko-canvas');
    const startRoundBtn = document.getElementById('start-round-button');
    const instructionText = document.getElementById('instruction-text');
    const triviaModal = document.getElementById('trivia-modal');
    const questionText = document.getElementById('question-text');
    const answerButtonsContainer = document.getElementById('answer-buttons');
    const resultMessage = document.getElementById('result-message');
    const closeModalBtn = document.getElementById('close-modal-button');

    const canvasWidth = 480;
    const canvasHeight = 640; // This is the VIEWPORT height
    const worldHeight = canvasHeight * 2; // World is now twice as tall
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    let totalScore = 0;
    let lastChangeText = 'Last Change: 0';
    let lastChangeColor = '#e2e8f0';
    let gamePhase = 'preGame'; // 'preGame', 'start', 'selectingFlower', 'answering'
    let lastAnswerWasCorrect = null;
    let questionCounter = 0;
    let isSuperDrop = false;
    let currentQuestionIndex = -1;
    let selectedFlowerIndex = null;
    let isWormholeActive = false;
    let wormholeTimer = null;
    let gameQuestionBank = [];
    let particles = [];

    // --- Question Bank ---
    const questionBank = [
        { question: "Which form is known as the 'Wage and Tax Statement'?", answers: ["Form 1040", "Form 1099-INT", "Form W-2", "Form W-4"], correct: 2 },
        { question: "What is the standard tax filing deadline for individuals in the U.S.?", answers: ["March 15", "April 15", "May 15", "June 15"], correct: 1 },
        { question: "Which filing status is for a married couple filing one tax return together?", answers: ["Single", "Head of Household", "Married Filing Separately", "Married Filing Jointly"], correct: 3 },
        { question: "To be a 'Qualifying Child', a child must generally be under what age at the end of the tax year?", answers: ["16", "18", "19", "21"], correct: 2 },
        { question: "If a child is a full-time student, the age limit for a 'Qualifying Child' is extended to under...", answers: ["21", "22", "23", "24"], correct: 3 },
        { question: "Which of these is NOT a test for a 'Qualifying Child'?", answers: ["Relationship Test", "Residency Test", "Support Test", "Citizenship Test"], correct: 3 },
        { question: "Wages, salaries, and tips are all examples of what type of income?", answers: ["Unearned Income", "Passive Income", "Earned Income", "Portfolio Income"], correct: 2 },
        { question: "Interest earned from a savings account is reported on which form?", answers: ["Form W-2", "Form 1099-G", "Form 1099-DIV", "Form 1099-INT"], correct: 3 },
        { question: "What does AGI stand for?", answers: ["Annual Gross Income", "Adjusted Gross Income", "Annual Government Interest", "Adjusted Government Interest"], correct: 1 },
        { question: "Can a taxpayer claim both the standard deduction and itemized deductions in the same year?", answers: ["Yes", "No", "Only if married", "Only if over 65"], correct: 1 },
        { question: "Which filing status generally results in the lowest tax liability?", answers: ["Single", "Married Filing Separately", "Head of Household", "Married Filing Jointly"], correct: 3 },
        { question: "A taxpayer who is unmarried and pays more than half the cost of keeping up a home for a qualifying person may use which filing status?", answers: ["Single", "Head of Household", "Qualifying Widow(er)", "Married Filing Separately"], correct: 1 },
        { question: "Gambling winnings are considered what type of income?", answers: ["Not Taxable", "Taxable Income", "Earned Income", "Capital Gain"], correct: 1 },
        { question: "The standard deduction amount depends on your filing status, age, and whether you are...", answers: ["Employed", "A student", "Blind", "A homeowner"], correct: 2 },
        { question: "Which of these is a common tax credit?", answers: ["Student Loan Interest Deduction", "Child Tax Credit", "IRA Deduction", "Tuition and Fees Deduction"], correct: 1 },
        { question: "What is the main difference between a tax credit and a tax deduction?", answers: ["They are the same", "A credit reduces your tax dollar-for-dollar", "A deduction reduces your tax dollar-for-dollar", "A credit is only for businesses"], correct: 1 },
        { question: "Which form is used to report miscellaneous income, such as from freelancing?", answers: ["Form W-2", "Form 1099-NEC", "Form 1040-ES", "Form 1099-R"], correct: 1 },
        { question: "The 'Support Test' for a qualifying relative means you must provide more than _______ of their total support for the year.", answers: ["25%", "One-third", "Half", "100%"], correct: 2 },
        { question: "For a person to be your 'Qualifying Relative', their gross income must be less than a certain amount. What is this amount for 2023?", answers: ["$1,000", "$3,500", "$4,700", "$10,000"], correct: 2 },
        { question: "If your spouse died during the tax year and you did not remarry, what filing status can you use for that year?", answers: ["Single", "Qualifying Widow(er)", "Head of Household", "Married Filing Jointly"], correct: 3 },
        { question: "Which of the following is generally NOT considered taxable income?", answers: ["Unemployment benefits", "A gift from a friend", "Rental income", "Alimony received (divorce after 2018)"], correct: 1 },
        { question: "The Earned Income Tax Credit (EITC) is a benefit for working people with...", answers: ["High income", "Low to moderate income", "Only investment income", "No children"], correct: 1 },
        { question: "What does the 'Residency Test' for a qualifying child mean?", answers: ["They must be a U.S. citizen", "They must have a passport", "They must live with you for more than half the year", "They must have their own room"], correct: 2 },
        { question: "Which of these is an 'above-the-line' deduction used to calculate AGI?", answers: ["Charitable contributions", "Mortgage interest", "Student loan interest", "State and local taxes"], correct: 2 },
        { question: "What is the purpose of Form W-4?", answers: ["To report your income to the IRS", "To tell your employer how much tax to withhold", "To request a tax extension", "To claim a dependent"], correct: 1 },
        { question: "If you are self-employed, you are generally responsible for paying which tax yourself?", answers: ["Property Tax", "Sales Tax", "Self-Employment Tax (Social Security & Medicare)", "Gasoline Tax"], correct: 2 },
        { question: "A tax credit that can result in a refund even if you don't owe any tax is called a...", answers: ["Nonrefundable credit", "Business credit", "Refundable credit", "Standard credit"], correct: 2 },
        { question: "Which of these is an example of unearned income?", answers: ["Wages from a job", "Tips", "Bonuses", "Dividends from stock"], correct: 3 },
        { question: "If you sell a stock for more than you paid for it, you have a...", answers: ["Capital Loss", "Dividend", "Capital Gain", "Royalty"], correct: 2 },
        { question: "The American Opportunity Tax Credit is for what type of expense?", answers: ["Medical expenses", "Childcare expenses", "Qualified education expenses", "Home renovation expenses"], correct: 2 },
        { question: "Which box on a Form W-2 shows your total federal wages, tips, and other compensation?", answers: ["Box 2", "Box 1", "Box 12", "Box 3"], correct: 1 },
        { question: "Which box on a Form W-2 shows the amount of federal income tax withheld?", answers: ["Box 1", "Box 2", "Box 4", "Box 6"], correct: 1 },
        { question: "Can you be claimed as a dependent if you file a joint return with your spouse?", answers: ["Yes, always", "Only if your income is low", "Generally, no", "Only if you are a student"], correct: 2 },
        { question: "The Child and Dependent Care Credit is for expenses paid so that you can...", answers: ["Go on vacation", "Work or look for work", "Volunteer", "Pay for school supplies"], correct: 1 },
        { question: "What is the maximum amount for the Child Tax Credit per qualifying child for tax year 2023?", answers: ["$500", "$1,000", "$2,000", "$3,600"], correct: 2 },
        { question: "If you receive a Form 1099-G, it likely shows what type of income?", answers: ["Gambling winnings", "Unemployment compensation", "Interest income", "Freelance income"], correct: 1 },
        { question: "Which of the following is an itemized deduction?", answers: ["Standard deduction", "Student loan interest", "Charitable contributions", "IRA contributions"], correct: 2 },
        { question: "What is the penalty for not filing a tax return on time?", answers: ["A fixed fee of $100", "A percentage of the unpaid tax", "A warning for the first offense", "There is no penalty"], correct: 1 },
        { question: "The 'Relationship Test' for a qualifying child includes your son, daughter, stepchild, or...", answers: ["Cousin", "Best friend", "Foster child", "Parent"], correct: 2 },
        { question: "What is the primary form used for individual U.S. federal income tax returns?", answers: ["Form 1120", "Form 941", "Form W-2", "Form 1040"], correct: 3 },
        { question: "Which of these cannot be claimed as a dependent?", answers: ["Your qualifying child", "Your qualifying relative", "Your friend who lives with you but you don't support", "Your parent who meets the qualifying relative tests"], correct: 2 },
        { question: "If you are single and under 65, you must file a tax return if your gross income exceeds the...", answers: ["Amount of tax you owe", "Standard deduction", "Personal exemption amount", "Poverty line"], correct: 1 },
        { question: "What does 'IRS' stand for?", answers: ["Internal Revenue Service", "Internal Revenue System", "International Revenue Service", "Internal Refund Service"], correct: 0 },
        { question: "The tax system in the United States is described as a _______ system.", answers: ["Flat", "Regressive", "Progressive", "Proportional"], correct: 2 },
        { question: "Which of the following is generally a non-taxable event?", answers: ["Selling a car for a profit", "Receiving a cash inheritance", "Winning the lottery", "Getting a year-end bonus"], correct: 1 },
        { question: "What is the purpose of estimated tax payments?", answers: ["To pay tax on income not subject to withholding", "To get a bigger refund", "To pay for property taxes", "To donate to the government"], correct: 0 },
        { question: "The 'Head of Household' filing status has a _______ standard deduction than the 'Single' filing status.", answers: ["Lower", "Higher", "Same", "It depends on income"], correct: 1 },
        { question: "Which form do you use to amend a previously filed tax return?", answers: ["Form 1040-A", "Form 1040-EZ", "Form 1040X", "Form 4868"], correct: 2 },
        { question: "Social Security benefits may be taxable depending on your...", answers: ["Age", "Filing status and other income", "State of residence", "Number of dependents"], correct: 1 },
        { question: "Which of these can you NOT deduct as an itemized deduction?", answers: ["State income taxes", "Mortgage interest", "Federal income taxes", "Charitable donations"], correct: 2 }
    ];

    // --- Physics Engine ---
    const engine = Engine.create({ gravity: { y: -1.2 } });
    const render = Render.create({
        canvas: canvas,
        engine: engine,
        options: { width: canvasWidth, height: canvasHeight, wireframes: false, background: '#4a5568' }
    });
    const runner = Runner.create();

    // --- Game Elements ---
    const world = engine.world;
    const pegs = [], buckets = [], balls = [], flowerHitboxes = [], flowers = [], sharks = [];
    let wormholeEntrance, wormholeExit;

    // Create Pegs
    const pegRows = 20, pegCols = 11, pegSpacingY = 50, pegSpacingX = 40;
    for (let row = 0; row < pegRows; row++) {
        const cols = pegCols + (row % 2 === 0 ? 0 : -1);
        const offsetX = (canvasWidth - (cols - 1) * pegSpacingX) / 2;
        for (let col = 0; col < cols; col++) {
            const x = offsetX + col * pegSpacingX;
            const y = 150 + row * pegSpacingY;
            pegs.push(Bodies.circle(x, y, 6, { isStatic: true, restitution: 0.6, friction: 0.1, render: { fillStyle: '#a0aec0' } }));
        }
    }

    // Create Buckets
    const numBuckets = 5, bucketHeight = 60, bucketY = bucketHeight / 2 + 20;
    const bucketPoints = [50, 20, 100, 20, 50];
    for (let i = 0; i < numBuckets; i++) {
        const x = (canvasWidth / numBuckets) * (i + 0.5);
        buckets.push(Bodies.rectangle(x, bucketY, pegSpacingX * 1.8, bucketHeight, { isStatic: true, isSensor: true, render: { fillStyle: getBucketColor(bucketPoints[i]) }, label: \`bucket-\${bucketPoints[i]}\` }));
        if (i > 0) World.add(world, Bodies.rectangle(x - (canvasWidth / numBuckets) / 2, bucketY, 8, bucketHeight, { isStatic: true, render: { fillStyle: '#2d3748' } }));
    }
    
    // Create Flowers & Hitboxes
    const numFlowers = 5, flowerY = worldHeight - 45, flowerRadius = 25;
    for (let i = 0; i < numFlowers; i++) {
        const x = (canvasWidth / (numFlowers + 1)) * (i + 1);
        flowers.push({ x, y: flowerY, radius: flowerRadius, isFlashing: false });
        flowerHitboxes.push(Bodies.circle(x, flowerY, flowerRadius, { isStatic: true, isSensor: true, label: \`flower-\${i}\`, render: { visible: false } }));
    }

    // Create Wormhole
    wormholeEntrance = Bodies.circle(canvasWidth / 2, worldHeight * 0.6, 30, {
        isStatic: true,
        isSensor: true,
        label: 'wormhole',
        render: { visible: false } 
    });
    wormholeExit = { x: canvasWidth / 2, y: buckets[2].position.y + 60, radius: 20 };

    // Create Sharks
    for (let i = 0; i < 2; i++) {
        const sharkBody = Bodies.circle(0, 0, 30, {
            isStatic: true,
            isSensor: true,
            label: \`shark-\${i}\`,
            render: { visible: false } // Custom rendered
        });
        sharks.push({ body: sharkBody, isEating: false });
    }

    // Walls
    const wallThickness = 20;
    World.add(world, [
        ...pegs, ...buckets, ...flowerHitboxes, wormholeEntrance, ...sharks.map(s => s.body),
        Bodies.rectangle(-wallThickness/2, worldHeight/2, wallThickness, worldHeight, { isStatic: true, render: { visible: false } }),
        Bodies.rectangle(canvasWidth + wallThickness/2, worldHeight/2, wallThickness, worldHeight, { isStatic: true, render: { visible: false } }),
        Bodies.rectangle(canvasWidth / 2, -wallThickness / 2, canvasWidth, wallThickness, { isStatic: true, isSensor: true, label: 'ceiling' }),
        Bodies.rectangle(canvasWidth / 2, worldHeight + wallThickness / 2, canvasWidth, wallThickness, { isStatic: true, render: { visible: false } })
    ]);

    // --- Camera & Game Logic ---
    let cameraY = worldHeight - canvasHeight;
    Render.lookAt(render, {
        min: { x: 0, y: cameraY },
        max: { x: canvasWidth, y: cameraY + canvasHeight }
    });

    function createBall(xPosition, isCorrect) {
        const ball = Bodies.circle(xPosition, worldHeight - 80, 10, {
            restitution: 0.8, friction: 0.05,
            render: { fillStyle: isCorrect ? '#48bb78' : '#f87171' },
            label: 'ball'
        });
        ball.isCorrect = isCorrect;
        balls.push(ball);
        World.add(world, ball);
    }

    function getBucketColor(points) {
        if (points >= 100) return '#48bb78';
        if (points >= 50) return '#4299e1';
        if (points >= 20) return '#f6e05e';
        return '#f56565';
    }
    
    function randomizeSharkPositions() {
        sharks.forEach(shark => {
            const x = Math.random() * (canvasWidth * 0.8) + (canvasWidth * 0.1);
            const y = Math.random() * (worldHeight * 0.5) + (worldHeight * 0.2);
            Body.setPosition(shark.body, { x, y });
        });
    }

    function shuffleQuestions() {
        gameQuestionBank = [...questionBank];
        for (let i = gameQuestionBank.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gameQuestionBank[i], gameQuestionBank[j]] = [gameQuestionBank[j], gameQuestionBank[i]];
        }
    }

    function showNextQuestion() {
        gamePhase = 'answering';
        instructionText.textContent = '';
        const q = gameQuestionBank[currentQuestionIndex];
        
        questionText.textContent = q.question;
        answerButtonsContainer.innerHTML = '';
        q.answers.forEach((answer, index) => {
            const button = document.createElement('button');
            button.textContent = answer;
            button.classList.add('answer-btn');
            button.addEventListener('click', () => handleAnswer(index === q.correct, button));
            answerButtonsContainer.appendChild(button);
        });

        resultMessage.textContent = '';
        closeModalBtn.style.display = 'none';
        triviaModal.classList.add('visible');
    }

    function handleAnswer(isCorrect, clickedButton) {
        lastAnswerWasCorrect = isCorrect;
        
        const answerButtons = Array.from(answerButtonsContainer.children);
        answerButtons.forEach(btn => btn.disabled = true);

        if (isCorrect) {
            clickedButton.classList.add('correct');
            resultMessage.textContent = "Correct!";
            resultMessage.className = 'correct-text';
        } else {
            clickedButton.classList.add('incorrect');
            const correctIndex = gameQuestionBank[currentQuestionIndex].correct;
            answerButtons[correctIndex].classList.add('correct');
            resultMessage.textContent = "Incorrect!";
            resultMessage.className = 'incorrect-text';
        }

        closeModalBtn.style.display = 'block';
    }
    
    function updateButtonForNextRound() {
        if ((questionCounter + 1) % 10 === 0) {
            startRoundBtn.textContent = 'Start SUPER DROP!';
            startRoundBtn.classList.add('super-drop-button');
        } else {
            startRoundBtn.textContent = 'Answer a Question';
            startRoundBtn.classList.remove('super-drop-button');
        }
    }

    // --- Event Handlers ---
    startRoundBtn.addEventListener('click', () => {
        if (gamePhase === 'preGame') {
            gamePhase = 'start';
            totalScore = 0;
            questionCounter = 0;
            lastChangeText = 'Last Change: 0';
            lastChangeColor = '#e2e8f0';
            instructionText.textContent = '';
            shuffleQuestions();
            updateButtonForNextRound();
            return;
        }

        questionCounter++;
        currentQuestionIndex++;
        isSuperDrop = (questionCounter % 10 === 0 && questionCounter > 0);
        
        startRoundBtn.style.display = 'none';
        randomizeSharkPositions();
        
        if (isSuperDrop) {
            instructionText.textContent = 'SUPER DROP! Answer for a 5-ball drop!';
            showNextQuestion();
        } else {
            gamePhase = 'selectingFlower';
            instructionText.textContent = 'Select a flower to drop from...';
        }
    });

    closeModalBtn.addEventListener('click', () => {
        triviaModal.classList.remove('visible');
        
        if (isSuperDrop) {
            flowers.forEach(flower => {
                createBall(flower.x, lastAnswerWasCorrect);
                flower.isFlashing = true;
                setTimeout(() => { flower.isFlashing = false; }, 250);
            });
        } else {
            const flower = flowers[selectedFlowerIndex];
            createBall(flower.x, lastAnswerWasCorrect);
            flower.isFlashing = true;
            setTimeout(() => { flower.isFlashing = false; }, 150);
        }

        gamePhase = 'start';
        startRoundBtn.style.display = 'block';
        updateButtonForNextRound();
        selectedFlowerIndex = null;
        isSuperDrop = false;
    });

    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
    World.add(world, mouseConstraint);

    Events.on(mouseConstraint, 'mousedown', (event) => {
        if (gamePhase !== 'selectingFlower') return;
        const mouseInWorld = {
            x: event.mouse.position.x,
            y: event.mouse.position.y + cameraY
        };
        const clickedBodies = Query.point(flowerHitboxes, mouseInWorld);
        if (clickedBodies.length > 0) {
            selectedFlowerIndex = parseInt(clickedBodies[0].label.split('-')[1]);
            showNextQuestion();
        }
    });

    Events.on(engine, 'collisionStart', (event) => {
        for (const pair of event.pairs) {
            let ball, other;
            if (pair.bodyA.label === 'ball') { ball = pair.bodyA; other = pair.bodyB; } 
            else if (pair.bodyB.label === 'ball') { ball = pair.bodyB; other = pair.bodyA; } 
            else { continue; }

            if (other.label.startsWith('bucket')) { handleBallInBucket(ball, other); } 
            else if (other.label === 'ceiling') { removeBall(ball); }
            else if (other.label === 'wormhole' && !ball.inWormhole) {
                ball.inWormhole = true; // Prevent re-triggering
                ball.fromWormhole = true; // Mark the ball for special effects
                isWormholeActive = true;
                clearTimeout(wormholeTimer);

                Body.setPosition(ball, { x: wormholeExit.x, y: wormholeExit.y });
                Body.setVelocity(ball, { x: 0, y: 5 }); // Corrected: Positive y is down

                ball.blinkUntil = engine.timing.timestamp + 2000;

                wormholeTimer = setTimeout(() => {
                    isWormholeActive = false;
                }, 2500); // Hold camera for 2.5 seconds
            } else if (other.label.startsWith('shark')) {
                const sharkIndex = parseInt(other.label.split('-')[1]);
                handleSharkAttack(ball, sharks[sharkIndex]);
            }
        }
    });
    
    function removeBall(ball) {
        setTimeout(() => {
            const ballIndex = balls.indexOf(ball);
            if (ballIndex > -1) balls.splice(ballIndex, 1);
            World.remove(world, ball);
        }, 100);
    }

    function createParticles(x, y) {
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                size: Math.random() * 4 + 2,
                lifespan: 120, // 2 seconds at 60fps
                color: \`hsl(\${Math.random() * 60 + 30}, 100%, 75%)\` // Yellows and oranges
            });
        }
    }

    function handleSharkAttack(ball, shark) {
        if (ball.isScored) return;
        ball.isScored = true;
        
        shark.isEating = true;
        setTimeout(() => { shark.isEating = false; }, 250);

        lastChangeText = 'Eaten!';
        lastChangeColor = '#a0aec0';
        removeBall(ball);
    }

    function handleBallInBucket(ball, bucket) {
        if (ball.isScored) return;
        ball.isScored = true;
        
        const points = parseInt(bucket.label.split('-')[1]);
        const change = ball.isCorrect ? points : -points;
        
        totalScore = Math.max(0, totalScore + change);
        
        lastChangeText = \`Last Change: \${change > 0 ? '+' : ''}\${change}\`;
        lastChangeColor = ball.isCorrect ? '#68d391' : '#fc8181';

        if (ball.fromWormhole && points === 100) {
            createParticles(ball.position.x, ball.position.y);
        }

        removeBall(ball);
    }
    
    // --- Camera and Drawing Logic ---
    Events.on(engine, 'beforeUpdate', () => {
        let targetY;
        if (isWormholeActive) {
            targetY = 0; // Force camera to the top
        } else if (balls.length > 0) {
            let highestBallY = worldHeight;
            balls.forEach(ball => {
                if (ball.position.y < highestBallY) {
                    highestBallY = ball.position.y;
                }
            });
            targetY = highestBallY - canvasHeight / 2;
        } else {
            targetY = worldHeight - canvasHeight; // Default to bottom when no balls
        }

        targetY = Math.max(0, targetY);
        targetY = Math.min(worldHeight - canvasHeight, targetY);

        cameraY += (targetY - cameraY) * 0.08;

        Render.lookAt(render, {
            min: { x: 0, y: cameraY },
            max: { x: canvasWidth, y: cameraY + canvasHeight }
        });

        // Update ball blinking
        balls.forEach(ball => {
            if (ball.blinkUntil && ball.blinkUntil > engine.timing.timestamp) {
                ball.render.visible = Math.floor(engine.timing.timestamp / 100) % 2 === 0;
            } else if (ball.blinkUntil) {
                ball.render.visible = true;
                delete ball.blinkUntil;
                delete ball.fromWormhole;
            }
        });
    });

    Events.on(render, 'afterRender', () => {
        const ctx = canvas.getContext('2d');
        
        // Draw world elements (affected by camera)
        ctx.save();
        ctx.translate(0, -cameraY);

        // Draw Wormhole Entrance
        const posEntrance = wormholeEntrance.position;
        const pulseEntrance = Math.sin(engine.timing.timestamp * 0.002) * 5 + 25;
        ctx.beginPath();
        ctx.arc(posEntrance.x, posEntrance.y, pulseEntrance, 0, Math.PI * 2);
        const gradientEntrance = ctx.createRadialGradient(posEntrance.x, posEntrance.y, 5, posEntrance.x, posEntrance.y, pulseEntrance);
        gradientEntrance.addColorStop(0, '#a0aec0');
        gradientEntrance.addColorStop(1, '#4a5568');
        ctx.fillStyle = gradientEntrance;
        ctx.fill();

        // Draw Wormhole Exit
        const posExit = wormholeExit;
        const pulseExit = Math.sin(engine.timing.timestamp * 0.002 + Math.PI) * 3 + 15;
        ctx.beginPath();
        ctx.arc(posExit.x, posExit.y, pulseExit, 0, Math.PI * 2);
        const gradientExit = ctx.createRadialGradient(posExit.x, posExit.y, 2, posExit.x, posExit.y, pulseExit);
        gradientExit.addColorStop(0, '#f6e05e');
        gradientExit.addColorStop(1, '#4a5568');
        ctx.fillStyle = gradientExit;
        ctx.fill();

        // Draw Sharks
        sharks.forEach(shark => {
            const pos = shark.body.position;
            const scale = shark.isEating ? 1.3 : 1;
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.scale(scale, scale);
            
            ctx.fillStyle = shark.isEating ? '#ef4444' : '#718096';
            
            // Body
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.quadraticCurveTo(0, -25, 30, 0);
            ctx.quadraticCurveTo(0, 25, -30, 0);
            ctx.fill();

            // Fin
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-5, -5);
            ctx.lineTo(5, -5);
            ctx.closePath();
            ctx.fill();
            
            // Tail
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.lineTo(-45, -10);
            ctx.lineTo(-45, 10);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.beginPath();
            ctx.arc(20, -5, 3, 0, Math.PI * 2);
            ctx.fillStyle = shark.isEating ? '#fff' : '#1a202c';
            ctx.fill();

            ctx.restore();
        });

        flowers.forEach((flower, index) => {
            ctx.save();
            ctx.translate(flower.x, flower.y);
            
            if(gamePhase === 'selectingFlower') {
                 const pulseFlower = Math.sin(engine.timing.timestamp * 0.005 + index) * 0.1 + 0.9;
                 ctx.globalAlpha = pulseFlower;
                 ctx.fillStyle = '#a0aec0';
            } else {
                ctx.fillStyle = '#718096';
            }
            if(flower.isFlashing) ctx.fillStyle = '#f6e05e';

            for (let i = 0; i < 6; i++) {
                ctx.rotate((Math.PI * 2) / 6);
                ctx.beginPath();
                ctx.arc(0, -15, 10, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fillStyle = flower.isFlashing ? '#fff' : '#f6e05e';
            ctx.fill();
            ctx.restore();
        });

        // Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05; // a little gravity
            p.lifespan--;

            ctx.globalAlpha = Math.max(0, p.lifespan / 120);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            
            if (p.lifespan <= 0) {
                particles.splice(i, 1);
            }
        }
        ctx.globalAlpha = 1;


        ctx.font = 'bold 16px Poppins';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        buckets.forEach((bucket, i) => {
            ctx.fillText(bucketPoints[i], bucket.position.x, bucket.position.y);
        });
        
        ctx.restore();

        // Draw UI Elements (not affected by camera)
        ctx.fillStyle = 'rgba(45, 55, 72, 0.8)';
        ctx.fillRect(0, 0, canvasWidth, 80);

        ctx.font = 'bold 36px Poppins';
        ctx.fillStyle = '#e2e8f0';
        ctx.textAlign = 'center';
        ctx.fillText('The Wall', canvasWidth / 2, 30);

        ctx.font = '16px Poppins';
        ctx.fillStyle = '#e2e8f0';
        ctx.textAlign = 'left';
        ctx.fillText(\`Question: \${questionCounter > 0 ? questionCounter : '-'}\`, 20, 60);

        ctx.font = 'bold 20px Poppins';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#e2e8f0';
        const scoreLabel = 'Score: ';
        const scoreTextWidth = ctx.measureText(scoreLabel).width;
        const scoreValueWidth = ctx.measureText(totalScore).width;
        const scoreStart = (canvasWidth / 2) - (scoreTextWidth + scoreValueWidth) / 2;
        ctx.fillText(scoreLabel, scoreStart + scoreTextWidth / 2, 60);
        ctx.fillStyle = '#68d391';
        ctx.fillText(totalScore, scoreStart + scoreTextWidth + scoreValueWidth / 2, 60);
        
        ctx.font = '16px Poppins';
        ctx.fillStyle = lastChangeColor;
        ctx.textAlign = 'right';
        ctx.fillText(lastChangeText, canvasWidth - 20, 60);
    });

    // --- Run the Game ---
    window.onload = () => {
        Render.run(render);
        Runner.run(runner, engine);
    }
<\/script>

</body>
</html>
`,
            farmRace: `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farm Race</title>
    <script src="https://cdn.tailwindcss.com"><\/script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka One', cursive;
            background-color: #34D399; /* A nice green for the background */
            margin: 0;
            overflow: hidden;
        }
        .text-shadow {
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
        }
        .animal-container, .character-card, .track-card {
            cursor: pointer;
        }
        .animal-container {
            transition: transform 0.3s ease-in-out;
        }
        .animal-container:hover {
            transform: scale(1.1) translateY(-10px);
        }
        .character-card {
            transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
        }
        .character-card:hover {
            transform: scale(1.05);
            background-color: #f0fdf4;
        }
        .character-card.selected {
            border-color: #22c55e;
            background-color: #dcfce7;
            transform: scale(1.05);
        }
        .track-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .track-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        canvas {
            background-color: #A3E635;
            display: block;
        }
        .hud-element {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1.5rem;
            border-radius: 0.75rem;
            border: 2px solid white;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-sky-400">

    <!-- VIEW 1: Start Screen -->
    <div id="startScreen">
        <div class="relative w-full h-screen flex flex-col items-center justify-center p-4">
            <div class="absolute top-8 left-8 w-24 h-24 sm:w-32 sm:h-32 bg-yellow-300 rounded-full shadow-lg animate-pulse"></div><div class="absolute top-16 right-12 w-32 h-16 bg-white rounded-full opacity-80"></div><div class="absolute top-24 right-24 w-48 h-24 bg-white rounded-full opacity-80"></div>
            <div class="text-center z-10 mb-8 md:mb-16"><h1 class="text-6xl sm:text-8xl lg:text-9xl text-white font-bold text-shadow"><span class="text-yellow-300">Farm</span><span class="text-red-500">Race</span></h1></div>
            <div class="z-30"><button id="startRaceButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-12 rounded-full text-2xl sm:text-3xl shadow-lg border-4 border-white transform hover:scale-105 transition-transform duration-300 ease-in-out">Start Race!</button></div>
            <div class="absolute bottom-[28%] sm:bottom-1/4 w-full flex justify-center items-end gap-4 sm:gap-8 z-20">
                <div class="animal-container flex flex-col items-center" data-character="Capy"><div class="relative w-24 h-20 sm:w-32 sm:h-28 bg-[#967969] rounded-t-full rounded-b-lg border-4 border-[#5C4033] shadow-lg"><div class="absolute top-8 left-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-8 right-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute bottom-2 left-1/2 -translate-x-1/2 w-12 h-6 bg-[#C6A692] rounded-md"><div class="absolute top-1 left-2 w-2 h-1 bg-[#5C4033] rounded-full"></div><div class="absolute top-1 right-2 w-2 h-1 bg-[#5C4033] rounded-full"></div></div><div class="absolute -top-2 left-3 w-6 h-6 bg-[#967969] rounded-full border-4 border-[#5C4033]"></div><div class="absolute -top-2 right-3 w-6 h-6 bg-[#967969] rounded-full border-4 border-[#5C4033]"></div></div><h3 class="mt-2 text-xl sm:text-2xl text-white text-shadow">Capy</h3></div>
                <div class="animal-container flex flex-col items-center" data-character="Bluey"><div class="relative w-24 h-28 sm:w-32 sm:h-36 bg-white rounded-t-full rounded-b-lg border-4 border-gray-400 shadow-lg"><div class="absolute -top-3 -right-2 w-12 h-16 bg-cyan-200 rounded-tl-full rounded-br-full -rotate-12"></div><div class="absolute top-0 left-0 w-full h-full bg-white rounded-t-full"></div><div class="absolute z-10 top-10 left-5 w-4 h-5 bg-gray-800 rounded-full flex items-center justify-center"><div class="w-1 h-1 bg-white rounded-full"></div></div><div class="absolute z-10 bottom-6 left-1/2 -translate-x-1/2 w-14 h-8 bg-gray-200 rounded-full"><div class="absolute top-3 left-3 w-2 h-1 bg-gray-500 rounded-full"></div><div class="absolute top-3 right-3 w-2 h-1 bg-gray-500 rounded-full"></div></div><div class="absolute z-10 -top-2 left-4 w-6 h-10 bg-white border-4 border-gray-400 rounded-tl-full rounded-tr-full rotate-12"></div></div><h3 class="mt-2 text-xl sm:text-2xl text-white text-shadow">Bluey</h3></div>
                <div class="animal-container flex flex-col items-center" data-character="Mooey"><div class="relative w-28 h-24 sm:w-36 sm:h-32 bg-white rounded-t-full rounded-b-lg border-4 border-gray-800 shadow-lg flex flex-col items-center justify-end"><div class="absolute w-12 h-12 bg-gray-800 rounded-full top-2 right-1 rotate-45"></div><div class="absolute w-8 h-8 bg-gray-800 rounded-full bottom-8 left-1 -rotate-45"></div><div class="absolute -top-2 left-6 w-6 h-6 bg-gray-200 rounded-t-full border-t-4 border-l-4 border-r-4 border-gray-400 transform -rotate-45"></div><div class="absolute -top-2 right-6 w-6 h-6 bg-gray-200 rounded-t-full border-t-4 border-l-4 border-r-4 border-gray-400 transform rotate-45"></div><div class="relative w-full h-full z-10 flex flex-col items-center"><div class="absolute top-10 left-8 w-4 h-4 bg-gray-800 rounded-full"></div><div class="absolute top-10 right-8 w-4 h-4 bg-gray-800 rounded-full"></div><div class="absolute bottom-4 w-16 h-10 bg-pink-300 rounded-full flex items-center justify-evenly"><div class="w-2 h-2 bg-pink-500 rounded-full"></div><div class="w-2 h-2 bg-pink-500 rounded-full"></div></div></div></div><h3 class="mt-2 text-xl sm:text-2xl text-white text-shadow">Mooey</h3></div>
                <div class="animal-container flex flex-col items-center" data-character="Scratch"><div class="relative w-20 h-24 sm:w-28 sm:h-32 bg-white p-2 rounded-full border-4 border-orange-500 shadow-lg flex flex-col items-center justify-center"><div class="absolute -top-3 left-1/2 -translate-x-1/2 w-8 h-5 bg-red-500 rounded-t-full border-b-2 border-red-700"></div><div class="absolute top-10 left-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-10 right-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-12 left-1/2 -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-t-8 border-l-transparent border-r-transparent border-t-yellow-400"></div><div class="absolute top-16 left-1/2 -translate-x-1/2 w-4 h-4 bg-red-500 rounded-full"></div></div><h3 class="mt-2 text-xl sm:text-2xl text-white text-shadow">Scratch</h3></div>
            </div>
            <div class="absolute bottom-0 left-0 w-full h-1/3 bg-green-500"><div class="absolute -top-16 w-[150%] h-32 bg-green-500 rounded-t-full -left-1/4"></div><div class="absolute -top-12 w-[120%] h-24 bg-green-600 rounded-t-full -right-[10%]"></div></div><div class="absolute bottom-0 left-0 w-full h-16 flex items-end z-30"><div class="w-full h-2 bg-white -mb-1"></div><div class="absolute w-full flex justify-around"><div class="w-2 h-12 bg-white rounded-t-sm"></div><div class="w-2 h-12 bg-white rounded-t-sm"></div><div class="w-2 h-12 bg-white rounded-t-sm"></div><div class="w-2 h-12 bg-white rounded-t-sm"></div><div class="w-2 h-12 bg-white rounded-t-sm"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden sm:block"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden sm:block"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden md:block"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden md:block"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden lg:block"></div><div class="w-2 h-12 bg-white rounded-t-sm hidden lg:block"></div></div></div>
        </div>
    </div>
    
    <!-- MODAL: Character Selection -->
    <div id="characterModal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 w-full max-w-4xl border-8 border-yellow-400">
            <h2 class="text-4xl sm:text-5xl text-gray-800 font-bold text-center mb-6">Choose Your Racer!</h2>
            <div id="characterGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4 sm:gap-6">
                <div class="character-card border-4 border-gray-200 rounded-lg p-4 flex flex-col items-center" data-character="Capy"><div class="relative w-24 h-20 bg-[#967969] rounded-t-full rounded-b-lg border-4 border-[#5C4033] shadow-lg mb-4"><div class="absolute top-8 left-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-8 right-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute bottom-2 left-1/2 -translate-x-1/2 w-12 h-6 bg-[#C6A692] rounded-md"><div class="absolute top-1 left-2 w-2 h-1 bg-[#5C4033] rounded-full"></div><div class="absolute top-1 right-2 w-2 h-1 bg-[#5C4033] rounded-full"></div></div><div class="absolute -top-2 left-3 w-6 h-6 bg-[#967969] rounded-full border-4 border-[#5C4033]"></div><div class="absolute -top-2 right-3 w-6 h-6 bg-[#967969] rounded-full border-4 border-[#5C4033]"></div></div><h3 class="text-2xl text-gray-700">Capy</h3></div>
                <div class="character-card border-4 border-gray-200 rounded-lg p-4 flex flex-col items-center" data-character="Bluey"><div class="relative w-24 h-28 bg-white rounded-t-full rounded-b-lg border-4 border-gray-400 shadow-lg mb-4"><div class="absolute -top-3 -right-2 w-12 h-16 bg-cyan-200 rounded-tl-full rounded-br-full -rotate-12"></div><div class="absolute top-0 left-0 w-full h-full bg-white rounded-t-full"></div><div class="absolute z-10 top-10 left-5 w-4 h-5 bg-gray-800 rounded-full flex items-center justify-center"><div class="w-1 h-1 bg-white rounded-full"></div></div><div class="absolute z-10 bottom-6 left-1/2 -translate-x-1/2 w-14 h-8 bg-gray-200 rounded-full"><div class="absolute top-3 left-3 w-2 h-1 bg-gray-500 rounded-full"></div><div class="absolute top-3 right-3 w-2 h-1 bg-gray-500 rounded-full"></div></div><div class="absolute z-10 -top-2 left-4 w-6 h-10 bg-white border-4 border-gray-400 rounded-tl-full rounded-tr-full rotate-12"></div></div><h3 class="text-2xl text-gray-700">Bluey</h3></div>
                <div class="character-card border-4 border-gray-200 rounded-lg p-4 flex flex-col items-center" data-character="Mooey"><div class="relative w-28 h-24 bg-white rounded-t-full rounded-b-lg border-4 border-gray-800 shadow-lg flex flex-col items-center justify-end mb-4"><div class="absolute w-12 h-12 bg-gray-800 rounded-full top-2 right-1 rotate-45"></div><div class="absolute w-8 h-8 bg-gray-800 rounded-full bottom-8 left-1 -rotate-45"></div><div class="absolute -top-2 left-6 w-6 h-6 bg-gray-200 rounded-t-full border-t-4 border-l-4 border-r-4 border-gray-400 transform -rotate-45"></div><div class="absolute -top-2 right-6 w-6 h-6 bg-gray-200 rounded-t-full border-t-4 border-l-4 border-r-4 border-gray-400 transform rotate-45"></div><div class="relative w-full h-full z-10 flex flex-col items-center"><div class="absolute top-10 left-8 w-4 h-4 bg-gray-800 rounded-full"></div><div class="absolute top-10 right-8 w-4 h-4 bg-gray-800 rounded-full"></div><div class="absolute bottom-4 w-16 h-10 bg-pink-300 rounded-full flex items-center justify-evenly"><div class="w-2 h-2 bg-pink-500 rounded-full"></div><div class="w-2 h-2 bg-pink-500 rounded-full"></div></div></div></div><h3 class="text-2xl text-gray-700">Mooey</h3></div>
                <div class="character-card border-4 border-gray-200 rounded-lg p-4 flex flex-col items-center" data-character="Scratch"><div class="relative w-24 h-28 bg-white p-2 rounded-full border-4 border-orange-500 shadow-lg flex flex-col items-center justify-center mb-4"><div class="absolute -top-3 left-1/2 -translate-x-1/2 w-8 h-5 bg-red-500 rounded-t-full border-b-2 border-red-700"></div><div class="absolute top-10 left-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-10 right-6 w-3 h-3 bg-gray-800 rounded-full"></div><div class="absolute top-12 left-1/2 -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-t-8 border-l-transparent border-r-transparent border-t-yellow-400"></div><div class="absolute top-16 left-1/2 -translate-x-1/2 w-4 h-4 bg-red-500 rounded-full"></div></div><h3 class="text-2xl text-gray-700">Scratch</h3></div>
            </div>
            <div class="text-center mt-8 flex justify-center gap-4">
                <button id="closeModalButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-10 rounded-lg text-xl">Cancel</button>
                <button id="confirmRacerButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-10 rounded-lg text-xl">Confirm Racer</button>
            </div>
        </div>
    </div>
    
    <!-- VIEW 2: Track Selection -->
    <div id="trackSelectScreen" class="hidden">
        <div class="relative w-full h-screen flex flex-col items-center justify-start p-4 pt-24 overflow-y-auto">
            <div class="text-center z-10 mb-10 absolute top-10"><h1 class="text-5xl sm:text-7xl text-white font-bold text-shadow">Select a Track</h1></div>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 z-10 w-full max-w-7xl">
                <!-- Track 1 -->
                <div class="track-card w-full rounded-2xl border-4 border-white shadow-lg p-6 bg-white bg-opacity-80" data-track="Barnyard Bonanza">
                    <div class="h-48 bg-[#D2B48C] rounded-lg mb-4 border-4 border-[#8B4513] flex items-center justify-center p-2"><div class="w-full h-full border-4 border-dashed border-[#A0522D] rounded-lg relative flex items-center justify-center"><div class="w-20 h-16 bg-red-600 border-2 border-red-800 rounded-md shadow-inner"></div><div class="absolute w-5 h-5 bg-yellow-400 rounded-full top-5 right-8"></div></div></div>
                    <div class="text-center"><h2 class="text-3xl text-gray-800 font-bold">Barnyard Bonanza</h2><p class="text-gray-600 mt-2 h-12">Dodge the wandering chicks on this classic dirt track!</p></div>
                    <button class="race-btn w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl shadow-md transform hover:scale-105 transition-transform duration-300">RACE!</button>
                </div>
                <!-- Track 2 -->
                <div class="track-card w-full rounded-2xl border-4 border-white shadow-lg p-6 bg-white bg-opacity-80" data-track="Cornfield Chase">
                    <div class="h-48 bg-[#FBBF24] rounded-lg mb-4 border-4 border-[#D97706] flex items-center justify-center p-2"><div class="w-full h-full border-4 border-dashed border-[#B45309] rounded-lg relative flex items-center justify-center"><div class="w-4 h-16 bg-green-700 rounded-t-md"></div><div class="absolute w-4 h-4 bg-[#8B4513] rounded-full bottom-5 left-8"></div></div></div>
                    <div class="text-center"><h2 class="text-3xl text-gray-800 font-bold">Cornfield Chase</h2><p class="text-gray-600 mt-2 h-12">Weave through the corn and avoid the scurrying mice!</p></div>
                    <button class="race-btn w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl shadow-md transform hover:scale-105 transition-transform duration-300">RACE!</button>
                </div>
                <!-- Track 3 -->
                <div class="track-card w-full rounded-2xl border-4 border-white shadow-lg p-6 bg-white bg-opacity-80" data-track="Pond Plunge">
                    <div class="h-48 bg-[#60A5FA] rounded-lg mb-4 border-4 border-[#2563EB] flex items-center justify-center p-2"><div class="w-full h-full border-4 border-dashed border-[#1D4ED8] rounded-lg relative flex items-center justify-center"><div class="w-24 h-12 bg-blue-400 rounded-full"></div><div class="absolute w-5 h-5 bg-green-600 rounded-full top-12 right-12"></div></div></div>
                    <div class="text-center"><h2 class="text-3xl text-gray-800 font-bold">Pond Plunge</h2><p class="text-gray-600 mt-2 h-12">Don't get stuck behind the slow green turtles!</p></div>
                    <button class="race-btn w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl shadow-md transform hover:scale-105 transition-transform duration-300">RACE!</button>
                </div>
                <!-- Track 4 -->
                 <div class="track-card w-full rounded-2xl border-4 border-white shadow-lg p-6 bg-white bg-opacity-80" data-track="Forest Frenzy">
                    <div class="h-48 bg-[#16A34A] rounded-lg mb-4 border-4 border-[#14532D] flex items-center justify-center p-2"><div class="w-full h-full border-4 border-dashed border-[#052e16] rounded-lg relative flex items-center justify-center"><div class="w-12 h-12 bg-green-900 rounded-full"></div><div class="absolute w-4 h-4 bg-gray-500 rounded-full bottom-8 left-12"></div></div></div>
                    <div class="text-center"><h2 class="text-3xl text-gray-800 font-bold">Forest Frenzy</h2><p class="text-gray-600 mt-2 h-12">A wild ride through the woods with speedy squirrels.</p></div>
                    <button class="race-btn w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl shadow-md transform hover:scale-105 transition-transform duration-300">RACE!</button>
                </div>
                 <!-- Track 5 -->
                 <div class="track-card w-full rounded-2xl border-4 border-white shadow-lg p-6 bg-white bg-opacity-80" data-track="Mountain Mayhem">
                    <div class="h-48 bg-[#A8A29E] rounded-lg mb-4 border-4 border-[#57534E] flex items-center justify-center p-2"><div class="w-full h-full border-4 border-dashed border-[#44403C] rounded-lg relative flex items-center justify-center"><div class="w-0 h-0 border-l-[20px] border-l-transparent border-b-[30px] border-b-gray-600 border-r-[20px] border-r-transparent"></div><div class="absolute w-4 h-4 bg-blue-500 rounded-full top-8 right-16"></div></div></div>
                    <div class="text-center"><h2 class="text-3xl text-gray-800 font-bold">Mountain Mayhem</h2><p class="text-gray-600 mt-2 h-12">A rocky road where little blue frogs hop around.</p></div>
                    <button class="race-btn w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-2xl shadow-md transform hover:scale-105 transition-transform duration-300">RACE!</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- VIEW 3: Race Game -->
    <div id="raceGameScreen" class="hidden relative w-full h-screen">
        <canvas id="gameCanvas"></canvas>
        <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-center z-10">
            <div class="hud-element text-2xl">Laps: <span id="laps">0/2</span></div>
            <div class="hud-element text-4xl"><span id="timer">00:00.00</span></div>
            <div class="hud-element text-2xl">Speed: <span id="speed">0</span></div>
        </div>
        <button id="quitRaceButton" class="absolute bottom-4 left-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full text-lg shadow-lg border-2 border-white">Quit</button>
    </div>

    <script>
        // --- UI Flow & State Management ---
        const startScreen = document.getElementById('startScreen');
        const trackSelectScreen = document.getElementById('trackSelectScreen');
        const raceGameScreen = document.getElementById('raceGameScreen');
        const characterModal = document.getElementById('characterModal');
        const startRaceButton = document.getElementById('startRaceButton');
        const animalContainers = document.querySelectorAll('.animal-container');
        const characterCards = document.querySelectorAll('#characterGrid .character-card');
        const closeModalButton = document.getElementById('closeModalButton');
        const confirmRacerButton = document.getElementById('confirmRacerButton');
        const trackCards = document.querySelectorAll('.track-card');
        const quitRaceButton = document.getElementById('quitRaceButton');
        let preselectedCharacter = null;
        let confirmedCharacter = null;
        let confirmedTrack = null;

        function openCharacterModal(characterName) {
            preselectedCharacter = characterName || 'Capy';
            updateCharacterSelectionUI();
            characterModal.classList.remove('hidden');
        }

        function updateCharacterSelectionUI() {
            characterCards.forEach(card => card.classList.toggle('selected', card.dataset.character === preselectedCharacter));
        }

        startRaceButton.addEventListener('click', () => openCharacterModal(null));
        animalContainers.forEach(animal => animal.addEventListener('click', () => openCharacterModal(animal.dataset.character)));
        closeModalButton.addEventListener('click', () => characterModal.classList.add('hidden'));
        characterCards.forEach(card => card.addEventListener('click', () => {
            preselectedCharacter = card.dataset.character;
            updateCharacterSelectionUI();
        }));
        confirmRacerButton.addEventListener('click', () => {
            confirmedCharacter = preselectedCharacter;
            characterModal.classList.add('hidden');
            startScreen.classList.add('hidden');
            trackSelectScreen.classList.remove('hidden');
        });
        trackCards.forEach(track => {
            if (track.dataset.track) {
                track.querySelector('.race-btn').addEventListener('click', () => {
                    confirmedTrack = track.dataset.track;
                    trackSelectScreen.classList.add('hidden');
                    raceGameScreen.classList.remove('hidden');
                    initGame();
                });
            }
        });
        quitRaceButton.addEventListener('click', () => {
            stopGame();
            confirmedCharacter = null; confirmedTrack = null; preselectedCharacter = null;
            raceGameScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        // --- Game Engine & Logic ---
        const gameElements = {
            canvas: null, ctx: null,
            lapsEl: null, timerEl: null, speedEl: null,
            gameRunning: false, startTime: 0, lapsCompleted: 0, canCompleteLap: false, lapsTotal: 2,
            keys: { ArrowLeft: false, ArrowRight: false, Space: false },
            player: { x: 0, y: 0, width: 30, height: 40, speed: 0, angle: 0, maxSpeed: 7, acceleration: 0.04, turnSpeed: 0.05, friction: 0.98, brakePower: 0.2, color: 'red' },
            racerColors: { 'Capy': '#967969', 'Bluey': '#81E6D9', 'Mooey': '#A0AEC0', 'Scratch': '#F6E05E' },
            creatures: []
        };

        function initGame() {
            gameElements.canvas = document.getElementById('gameCanvas');
            gameElements.ctx = gameElements.canvas.getContext('2d');
            gameElements.lapsEl = document.getElementById('laps');
            gameElements.timerEl = document.getElementById('timer');
            gameElements.speedEl = document.getElementById('speed');
            gameElements.canvas.width = window.innerWidth;
            gameElements.canvas.height = window.innerHeight;

            gameElements.player.x = gameElements.canvas.width / 2 - 150;
            gameElements.player.y = gameElements.canvas.height - 170;
            gameElements.player.speed = 0;
            gameElements.player.angle = 0;
            gameElements.player.color = gameElements.racerColors[confirmedCharacter] || 'red';
            
            gameElements.lapsCompleted = 0;
            gameElements.canCompleteLap = false;
            gameElements.lapsEl.textContent = \`0/\${gameElements.lapsTotal}\`;
            
            // Create obstacles based on the selected track
            switch(confirmedTrack) {
                case "Barnyard Bonanza":
                    createCreatures(15, '#FBBF24', 10); // Yellow Chicks
                    break;
                case "Cornfield Chase":
                    createCreatures(20, '#8B4513', 8); // Brown Mice
                    break;
                case "Pond Plunge":
                    createCreatures(10, '#16A34A', 15); // Green Turtles
                    break;
                case "Forest Frenzy":
                    createCreatures(25, '#9CA3AF', 9); // Gray Squirrels
                    break;
                case "Mountain Mayhem":
                     createCreatures(18, '#3B82F6', 12); // Blue Frogs
                    break;
            }

            gameElements.startTime = Date.now();
            gameElements.gameRunning = true;
            gameLoop();
        }

        function createCreatures(count, color, size) {
            gameElements.creatures = [];
            for (let i = 0; i < count; i++) {
                gameElements.creatures.push({
                    x: Math.random() * gameElements.canvas.width,
                    y: Math.random() * gameElements.canvas.height,
                    size: size,
                    color: color,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }
        }

        function stopGame() {
            gameElements.gameRunning = false;
        }

        function drawTrack() {
            const { ctx, canvas } = gameElements;
            ctx.fillStyle = '#16A34A';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#D2B48C';
            ctx.beginPath();
            ctx.ellipse(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 80, canvas.height / 2 - 80, 0, 0, 2 * Math.PI);
            ctx.ellipse(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 220, canvas.height / 2 - 180, 0, 0, 2 * Math.PI);
            ctx.fill('evenodd');
            ctx.fillStyle = 'white'; 
            ctx.fillRect(canvas.width / 2 - 70, canvas.height - 180, 140, 20);
        }

        function drawPlayer() {
            const { ctx, player } = gameElements;
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = player.color;
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 4;
            ctx.fillRect(-player.height / 2, -player.width / 2, player.height, player.width);
            ctx.strokeRect(-player.height / 2, -player.width / 2, player.height, player.width);
            ctx.fillStyle = 'yellow'; 
            ctx.fillRect(player.height/2 - 8, -player.width/2 + 5, 5, 5);
            ctx.fillRect(player.height/2 - 8, player.width/2 - 10, 5, 5);
            ctx.restore();
        }

        function drawCreatures() {
            const { ctx, creatures } = gameElements;
            creatures.forEach(creature => {
                ctx.fillStyle = creature.color;
                ctx.beginPath();
                ctx.arc(creature.x, creature.y, creature.size / 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function update() {
            const { player, keys, canvas, creatures, lapsTotal } = gameElements;
            if (player.speed > 0.1) {
                 if (keys.ArrowLeft) player.angle -= player.turnSpeed * (player.speed / player.maxSpeed);
                 if (keys.ArrowRight) player.angle += player.turnSpeed * (player.speed / player.maxSpeed);
            }
            if (keys.Space) {
                if (player.speed > 0) player.speed -= player.brakePower;
                if (player.speed < 0) player.speed = 0;
            } else {
                if (player.speed < player.maxSpeed) player.speed += player.acceleration;
            }
            player.speed *= player.friction;
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;

            creatures.forEach(creature => {
                creature.x += creature.vx;
                creature.y += creature.vy;
                if (creature.x < 0 || creature.x > canvas.width) creature.vx *= -1;
                if (creature.y < 0 || creature.y > canvas.height) creature.vy *= -1;
                const dist = Math.hypot(player.x - creature.x, player.y - creature.y);
                if (dist < player.width / 2 + creature.size / 2) {
                    player.speed *= 0.95; // Slow down a bit more
                }
            });

            const finishLineY = canvas.height - 180;
            const checkpointY = 180;
            if (player.y < checkpointY) {
                gameElements.canCompleteLap = true;
            }
            if (gameElements.canCompleteLap && player.y > finishLineY && player.x > canvas.width / 2 - 70 && player.x < canvas.width / 2 + 70) {
                gameElements.lapsCompleted++;
                gameElements.canCompleteLap = false;
                if (gameElements.lapsCompleted >= lapsTotal) {
                    stopGame();
                    gameElements.lapsEl.textContent = \`Finish!\`;
                } else {
                    gameElements.lapsEl.textContent = \`\${gameElements.lapsCompleted}/\${lapsTotal}\`;
                }
            }

            gameElements.speedEl.textContent = Math.round(player.speed * 10);
            const elapsedTime = Date.now() - gameElements.startTime;
            const minutes = String(Math.floor(elapsedTime / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((elapsedTime % 60000) / 1000)).padStart(2, '0');
            const ms = String(elapsedTime % 1000).padStart(3, '0').slice(0, 2);
            gameElements.timerEl.textContent = \`\${minutes}:\${seconds}.\${ms}\`;
        }

        function gameLoop() {
            if (!gameElements.gameRunning) return;
            update();
            gameElements.ctx.clearRect(0, 0, gameElements.canvas.width, gameElements.canvas.height);
            drawTrack();
            drawCreatures();
            drawPlayer();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => { if (e.code in gameElements.keys) gameElements.keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { if (e.code in gameElements.keys) gameElements.keys[e.code] = false; });
        window.addEventListener('resize', () => {
             if(gameElements.gameRunning) {
                gameElements.canvas.width = window.innerWidth;
                gameElements.canvas.height = window.innerHeight;
             }
        });

    <\/script>
</body>
</html>
`,
            collector: `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Collecting Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: sans-serif;
            background-color: #f0f0f0;
        }
        #gameArea {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #333;
            background-color: #eee;
            margin-bottom: 20px;
            overflow: hidden;
        }
        #player {
            width: 40px;
            height: 40px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            z-index: 2;
            transition: width 0.1s ease-out, height 0.1s ease-out, border 0.1s ease-out, background-color 0.1s ease-out; /* Added transitions for smooth color/border change */
            border: 1px solid white;
        }
        /* New player states */
        #player.dominant {
            border: 1px solid blue;
            background-color: grey;
        }

        .collectable {
            position: absolute;
            transition: background-color 0.1s ease-out, left 0.1s ease-out, top 0.1s ease-out;
        }

        .collectable-small {
            width: 10px;
            height: 10px;
            border: solid black 1.5px;
        }
        .collectable-medium {
            width: 20px;
            height: 20px;
            order: solid black 2px;
        }
        .collectable-large {
            width: 30px;
            height: 30px;
            order: solid black 3px;
        }

        .collectable-circle {
            border-radius: 50%;
        }
        .collectable-square {
            /* Default div is a square, no special styling needed */
        }
        .collectable-triangle {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 20px solid;
        }
        .collectable-cylinder {
            border-radius: 50%;
        }


        .explosion {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: orange;
            position: absolute;
            animation: explode 0.5s ease-out forwards;
            z-index: 3;
        }
        @keyframes explode {
            from {
                transform: scale(0);
                opacity: 1;
            }
            to {
                transform: scale(2);
                opacity: 0;
            }
        }

        #startButton, #restartButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #message {
            font-size: 20px;
            margin-bottom: 10px;
        }
        /* Container for the two-column display */
        #statsContainer {
            display: flex;
            justify-content: space-around;
            width: 600px;
            margin-bottom: 10px;
        }
        .stats-column {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        #levelDisplay, #itemsLeftDisplay, #playerSizeDisplay, #timer, #largestObjectDisplay, #scoreDisplay, #livesDisplay, #highScoreDisplay {
            font-size: 18px;
            margin-bottom: 5px;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="gameArea">
        <div id="player"></div>
    </div>
    <div id="message">Collect all items!</div>
    <div id="statsContainer">
        <div class="stats-column">
            <div id="levelDisplay">Level: <span id="levelNumber">1</span></div>
            <div id="itemsLeftDisplay">Objects Left: <span id="itemsLeftNumber">0</span></div>
            <div id="scoreDisplay">Score: <span id="currentScore">0</span></div>
            <div id="timer">Time Left: <span id="timeLeft">0</span> seconds</div> </div>
        <div class="stats-column">
            <div id="playerSizeDisplay">Player Size: <span id="playerCurrentSize">0.0</span>px</div>
            <div id="largestObjectDisplay">Largest Object: <span id="largestObjectSize">0.0</span>px</div>
            <div id="livesDisplay">Lives: <span id="currentLives">3</span></div>
            <div id="highScoreDisplay">High Score: <span id="sessionHighScore">0</span></div>
        </div>
    </div>
    <button id="startButton">Start</button>
    <button id="restartButton" style="display:none;">Restart</button>
    <script>
        const gameArea = document.getElementById('gameArea');
        const player = document.getElementById('player');
        const message = document.getElementById('message');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const timerDisplay = document.getElementById('timeLeft');
        const collectedItems = new Set();
        const levelNumberDisplay = document.getElementById('levelNumber');
        const itemsLeftNumberDisplay = document.getElementById('itemsLeftNumber');
        const playerCurrentSizeDisplay = document.getElementById('playerCurrentSize');
        const largestObjectSizeDisplay = document.getElementById('largestObjectSize');
        const currentScoreDisplay = document.getElementById('currentScore');
        const currentLivesDisplay = document.getElementById('currentLives');
        const sessionHighScoreDisplay = document.getElementById('sessionHighScore');

        let playerX = 0;
        let playerY = 0;
        const INITIAL_PLAYER_SIZE = 40;
        let playerSize = INITIAL_PLAYER_SIZE;
        let collectGrowthRate = 0.6;
        let itemsLeft = 0;
        let intervalId;
        let animationFrameId;
        let timeLimit = 60;
        const MIN_TIME_LIMIT = 20;
        let timeLeft;
        let level = 1;
        let numberOfItems = 5;
        let score = 0;
        const INITIAL_LIVES = 3;
        let lives = INITIAL_LIVES;
        let sessionHighScore = 0;
        let backgroundColors = ["#eee", "pink", "teal", "green"]

        let keysPressed = {};
        const PLAYER_SPEED = 3;

        const collectableSizes = [
            { name: 'small', class: 'collectable-small', volume: 1, baseSize: 10 },
            { name: 'medium', class: 'collectable-medium', volume: 2, baseSize: 20 },
            { name: 'large', class: 'collectable-large', volume: 3, baseSize: 30 }
        ];

        const collectableShapes = [
            { name: 'circle', class: 'collectable-circle', widthFactor: 1, heightFactor: 1 },
            { name: 'square', class: 'collectable-square', widthFactor: 1, heightFactor: 1 },
            { name: 'triangle', class: 'collectable-triangle', widthFactor: 2, heightFactor: 2 },
            { name: 'cylinder', class: 'collectable-cylinder', widthFactor: 1.5, heightFactor: 1 }
        ];

        function getRandomDarkColor() {
            const hue = Math.floor(Math.random() * 360);
            const saturation = Math.floor(Math.random() * 30) + 70;
            const lightness = Math.floor(Math.random() * 20) + 20;
            return \`hsl(\${hue}, \${saturation}%, \${lightness}%)\`;
        }

        function createCollectable(idPrefix, index, x, y, chosenSize, chosenShape) {
            const collectable = document.createElement('div');

            collectable.className = \`collectable \${chosenSize.class} \${chosenShape.class}\`;
            collectable.id = \`\${idPrefix}-\${index}\`;
            collectable.style.backgroundColor = getRandomDarkColor();

            let actualWidth = chosenSize.baseSize * chosenShape.widthFactor;
            let actualHeight = chosenSize.baseSize * chosenShape.heightFactor;

            if (chosenShape.name === 'triangle') {
                collectable.style.backgroundColor = '';
                collectable.style.borderBottomColor = getRandomDarkColor();
                collectable.style.borderLeftWidth = (chosenSize.baseSize * chosenShape.widthFactor / 2) + 'px';
                collectable.style.borderRightWidth = (chosenSize.baseSize * chosenShape.widthFactor / 2) + 'px';
                collectable.style.borderBottomWidth = (chosenSize.baseSize * chosenShape.heightFactor) + 'px';
                actualWidth = chosenSize.baseSize * chosenShape.widthFactor;
                actualHeight = chosenSize.baseSize * chosenShape.heightFactor;
            } else {
                collectable.style.width = actualWidth + 'px';
                collectable.style.height = actualHeight + 'px';
            }

            collectable.style.left = x + 'px';
            collectable.style.top = y + 'px';

            collectable.dataset.x = x;
            collectable.dataset.y = y;
            collectable.dataset.volume = chosenSize.volume;
            collectable.dataset.size = Math.max(actualWidth, actualHeight);
            return collectable;
        }

        // Variable to store the current largest object size
        let currentLargestObjectSize = 0;

        function updateLargestObjectDisplay() {
            let tempLargestSize = 0; // Use a temporary variable
            document.querySelectorAll('.collectable').forEach(item => {
                const itemVisualSize = parseFloat(item.dataset.size);
                if (itemVisualSize > tempLargestSize) {
                    tempLargestSize = itemVisualSize;
                }
            });
            currentLargestObjectSize = tempLargestSize; // Update the global variable
            largestObjectSizeDisplay.textContent = currentLargestObjectSize.toFixed(1) + 'px';
        }

        // New function to update player's visual state based on size comparison
        function updatePlayerVisualState() {
            if (playerSize > currentLargestObjectSize && currentLargestObjectSize > 0) { // currentLargestObjectSize > 0 to avoid false positive when no objects
                player.classList.add('dominant');
            } else {
                player.classList.remove('dominant');
            }
        }


        function generateCollectables() {
            collectedItems.clear();
            gameArea.querySelectorAll('.collectable').forEach(item => item.remove());
            gameArea.querySelectorAll('.explosion').forEach(exp => exp.remove());
            
            let currentCollectables = [];
            let largestItemSizeInCurrentLevel = 0;
            let totalVolumeOfInitiallyCollectibleItems = 0;

            let maxCollectableDimensionForPlacement = 0;
            collectableSizes.forEach(s => {
                collectableShapes.forEach(sh => {
                    maxCollectableDimensionForPlacement = Math.max(maxCollectableDimensionForPlacement, s.baseSize * Math.max(sh.widthFactor, sh.heightFactor));
                });
            });

            for (let i = 0; i < numberOfItems; i++) {
                const x = Math.random() * (gameArea.clientWidth - maxCollectableDimensionForPlacement);
                const y = Math.random() * (gameArea.clientHeight - maxCollectableDimensionForPlacement);
                const randomSizeIndex = Math.floor(Math.random() * collectableSizes.length);
                const chosenSize = collectableSizes[randomSizeIndex];
                const randomShapeIndex = Math.floor(Math.random() * collectableShapes.length);
                const chosenShape = collectableShapes[randomShapeIndex];

                const newCollectable = createCollectable('item', i, x, y, chosenSize, chosenShape);
                currentCollectables.push(newCollectable);
                
                const itemVisualSize = parseFloat(newCollectable.dataset.size);
                const itemVolume = parseFloat(newCollectable.dataset.volume);

                largestItemSizeInCurrentLevel = Math.max(largestItemSizeInCurrentLevel, itemVisualSize);
                
                if (itemVisualSize <= INITIAL_PLAYER_SIZE) {
                    totalVolumeOfInitiallyCollectibleItems += itemVolume;
                }
            }

            let currentGrowthPotential = INITIAL_PLAYER_SIZE + (totalVolumeOfInitiallyCollectibleItems * collectGrowthRate);
            let itemsAddedForWinnability = 0;

            while (currentGrowthPotential < largestItemSizeInCurrentLevel) {
                const x = Math.random() * (gameArea.clientWidth - collectableSizes[0].baseSize);
                const y = Math.random() * (gameArea.clientHeight - collectableSizes[0].baseSize);
                const smallItemSize = collectableSizes[0];
                const randomShapeIndex = Math.floor(Math.random() * collectableShapes.length);
                const chosenShape = collectableShapes[randomShapeIndex];

                const newCollectable = createCollectable('winnable-item', itemsAddedForWinnability + numberOfItems, x, y, smallItemSize, chosenShape);
                currentCollectables.push(newCollectable);
                
                currentGrowthPotential += parseFloat(newCollectable.dataset.volume) * collectGrowthRate;
                itemsAddedForWinnability++;
            }

            currentCollectables.forEach(item => gameArea.appendChild(item));
            itemsLeft = currentCollectables.length;
            message.textContent = \`Collect all \${itemsLeft} items!\`;
            itemsLeftNumberDisplay.textContent = itemsLeft;
            currentScoreDisplay.textContent = Math.round(score);
            updateLargestObjectDisplay(); // Initial update for the largest object display
            updatePlayerVisualState(); // Update player visual state after generating objects
        }

        function handleKeyDown(e) {
            keysPressed[e.key] = true;
        }

        function handleKeyUp(e) {
            keysPressed[e.key] = false;
        }

        function gameLoop() {
            try {
                const gameAreaWidth = gameArea.clientWidth;
                const gameAreaHeight = gameArea.clientHeight;

                if (keysPressed['ArrowLeft']) {
                    playerX = Math.max(0, playerX - PLAYER_SPEED);
                }
                if (keysPressed['ArrowRight']) {
                    playerX = Math.min(gameAreaWidth - playerSize, playerX + PLAYER_SPEED);
                }
                if (keysPressed['ArrowUp']) {
                    playerY = Math.max(0, playerY - PLAYER_SPEED);
                }
                if (keysPressed['ArrowDown']) {
                    playerY = Math.min(gameAreaHeight - playerSize, playerY + PLAYER_SPEED);
                }

                player.style.left = playerX + 'px';
                player.style.top = playerY + 'px';

                checkCollision();
                updatePlayerVisualState(); // Update player visual state in every frame

            } catch (error) {
                console.error("Error in gameLoop:", error);
                cancelAnimationFrame(animationFrameId);
                message.textContent = "Game Error! Check console.";
            } finally {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function checkCollision() {
            try {
                const playerRect = player.getBoundingClientRect();

                document.querySelectorAll('.collectable').forEach(item => {
                    const itemRect = item.getBoundingClientRect();

                    if (
                        playerRect.x < itemRect.x + itemRect.width &&
                        playerRect.x + playerRect.width > itemRect.x &&
                        playerRect.y < itemRect.y + itemRect.height &&
                        playerRect.y + playerRect.height > itemRect.y
                    ) {
                        if (!collectedItems.has(item.id)) {
                            const itemVisualSize = parseFloat(item.dataset.size);

                            if (itemVisualSize > playerSize) {
                                const BOUNCE_FORCE = 30;

                                const playerCenterX = playerX + playerSize / 2;
                                const playerCenterY = playerY + playerSize / 2;
                                const itemCenterX = parseFloat(item.dataset.x) + itemVisualSize / 2;
                                const itemCenterY = parseFloat(item.dataset.y) + itemVisualSize / 2;

                                let dx = itemCenterX - playerCenterX;
                                let dy = itemCenterY - playerCenterY;

                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance === 0) {
                                    dx = (Math.random() - 0.5) * 2;
                                    dy = (Math.random() - 0.5) * 2;
                                } else {
                                    dx /= distance;
                                    dy /= distance;
                                }

                                let new_item_x = parseFloat(item.dataset.x) + dx * BOUNCE_FORCE;
                                let new_item_y = parseFloat(item.dataset.y) + dy * BOUNCE_FORCE;

                                new_item_x = Math.max(0, Math.min(new_item_x, gameArea.clientWidth - itemVisualSize));
                                new_item_y = Math.max(0, Math.min(new_item_y, gameArea.clientHeight - itemVisualSize));

                                item.style.left = new_item_x + 'px';
                                item.style.top = new_item_y + 'px';
                                item.dataset.x = new_item_x;
                                item.dataset.y = new_item_y;

                                message.textContent = 'Object too big! Bounced!';
                            } else {
                                collectedItems.add(item.id);
                                itemsLeft--;
                                itemsLeftNumberDisplay.textContent = itemsLeft;
                                
                                score += playerSize;
                                currentScoreDisplay.textContent = Math.round(score);

                                const itemVolume = parseFloat(item.dataset.volume);
                                const growthAmount = itemVolume * collectGrowthRate;
                                playerSize += growthAmount;

                                player.style.width = playerSize + 'px';
                                player.style.height = playerSize + 'px';
                                playerCurrentSizeDisplay.textContent = playerSize.toFixed(1);

                                playerX = Math.min(gameArea.clientWidth - playerSize, Math.max(0, playerX));
                                playerY = Math.min(gameArea.clientHeight - playerSize, Math.max(0, playerY));
                                player.style.left = playerX + 'px';
                                player.style.top = playerY + 'px';

                                const explosion = document.createElement('div');
                                explosion.className = 'explosion';
                                const itemSize = parseFloat(item.dataset.size);
                                const itemCenterX = parseFloat(item.dataset.x) + (itemSize / 2) - 15;
                                const itemCenterY = parseFloat(item.dataset.y) + (itemSize / 2) - 15;
                                explosion.style.left = itemCenterX + 'px';
                                explosion.style.top = itemCenterY + 'px';
                                gameArea.appendChild(explosion);

                                item.remove();
                                setTimeout(() => {
                                    explosion.remove();
                                }, 500);
                                
                                updateLargestObjectDisplay(); // Update largest object display after collection
                                updatePlayerVisualState(); // Update player visual state after collection

                                if (itemsLeft === 0) {
                                    clearInterval(intervalId);
                                    cancelAnimationFrame(animationFrameId);
                                    document.removeEventListener('keydown', handleKeyDown);
                                    document.removeEventListener('keyup', handleKeyUp);
                                    
                                    const timeBonus = timeLeft * 10;
                                    score += timeBonus;
                                    currentScoreDisplay.textContent = Math.round(score);
                                    
                                    message.textContent = \`You win! Bonus: \${timeBonus} points!\`;
                                    startButton.textContent = 'Next Level';
                                    startButton.style.display = 'block';
                                    restartButton.style.display = 'none';
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error("Error in checkCollision:", error);
            }
        }

        function startGame() {
            keysPressed = {};

            if (intervalId) clearInterval(intervalId);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            const isBrandNewGame = (startButton.textContent === 'Start' || startButton.textContent === 'Restart Game');

            if (isBrandNewGame) {
                level = 1;
                timeLimit = 60;
                playerSize = INITIAL_PLAYER_SIZE;
                
                if (score > sessionHighScore) {
                    sessionHighScore = score;
                }
                score = 0;
                lives = INITIAL_LIVES;
            } else if (startButton.textContent === 'Next Level') {
                level++;
                timeLimit = Math.max(MIN_TIME_LIMIT, timeLimit - 2);
                playerSize = INITIAL_PLAYER_SIZE;
            } else if (startButton.textContent === 'Continue') {
                playerSize = INITIAL_PLAYER_SIZE;
                timeLimit = 60;
            }


            if (lives <= 0 && !isBrandNewGame) {
                message.textContent = 'GAME OVER! No lives left.';
                startButton.textContent = 'Restart Game';
                startButton.style.display = 'block';
                restartButton.style.display = 'none';
                return;
            }

            gameArea.style.backgroundColor = backgroundColors[level % backgroundColors.length];

            numberOfItems = level * 3;

            levelNumberDisplay.textContent = level;
            itemsLeftNumberDisplay.textContent = numberOfItems;
            player.style.width = playerSize + 'px';
            player.style.height = playerSize + 'px';
            playerCurrentSizeDisplay.textContent = playerSize.toFixed(1);
            currentScoreDisplay.textContent = Math.round(score);
            currentLivesDisplay.textContent = lives;
            sessionHighScoreDisplay.textContent = Math.round(sessionHighScore);

            playerX = gameArea.clientWidth / 2 - (playerSize / 2);
            playerY = gameArea.clientHeight - (playerSize / 2) - 10;
            player.style.left = playerX + 'px';
            player.style.top = playerY + 'px';

            generateCollectables(); // This will call updateLargestObjectDisplay and updatePlayerVisualState
            timeLeft = timeLimit;
            timerDisplay.textContent = timeLeft;
            message.textContent = 'Game started!';
            startButton.style.display = 'none';
            restartButton.style.display = 'none';

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            animationFrameId = requestAnimationFrame(gameLoop);

            intervalId = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(intervalId);
                    cancelAnimationFrame(animationFrameId);
                    document.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('keyup', handleKeyUp);

                    if (itemsLeft > 0) {
                        lives--;
                        currentLivesDisplay.textContent = lives;
                        if (lives <= 0) {
                            message.textContent = 'GAME OVER! No lives left.';
                            if (score > sessionHighScore) {
                                sessionHighScore = score;
                                sessionHighScoreDisplay.textContent = Math.round(sessionHighScore);
                            }
                            startButton.textContent = 'Restart Game';
                            startButton.style.display = 'block';
                            restartButton.style.display = 'none';
                        } else {
                            message.textContent = \`Oops, lost a life! Lives: \${lives}\`;
                            startButton.textContent = 'Continue';
                            startButton.style.display = 'block';
                            restartButton.style.display = 'none';
                        }
                    } else {
                        const timeBonus = timeLeft * 10;
                        score += timeBonus;
                        currentScoreDisplay.textContent = Math.round(score);
                        
                        message.textContent = \`You win! Bonus: \${timeBonus} points!\`;
                        startButton.textContent = 'Next Level';
                        startButton.style.display = 'block';
                        restartButton.style.display = 'none';
                    }
                }
            }, 1000);
        }

        function restartGame() {
            keysPressed = {};
            startGame();
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
    <\/script>
</body>
</html>
`,
            taxPlinkov1: `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wall - Plinko Trivia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"><\/script>
    <script src="https://cdn.tailwindcss.com"><\/script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 500px;
            margin: 1rem;
        }
        canvas {
            background-color: #4a5568;
            border-radius: 1rem;
            width: 100%;
            height: auto;
            order: -1; /* Draw canvas above title for visual flow */
            cursor: pointer;
        }
        .info-display {
            margin-top: 1.5rem;
            text-align: center;
        }
        .score-display {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f7fafc;
        }
        .score-display span {
            color: #68d391;
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-4xl font-bold my-6 text-center">Anti-Gravity Plinko</h1>
    <canvas id="plinko-canvas"></canvas>
    <div class="info-display">
        <div id="score-display" class="score-display">Score: <span id="score">0</span></div>
        <div id="last-win-display" class="mt-2 text-lg">Last Win: <span id="last-win">0</span></div>
    </div>
</div>

<script>
    // --- Matter.js Aliases ---
    const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Mouse, MouseConstraint, Query } = Matter;

    // --- Game Setup ---
    const canvas = document.getElementById('plinko-canvas');
    const scoreElement = document.getElementById('score');
    const lastWinElement = document.getElementById('last-win');

    const canvasWidth = 480;
    const canvasHeight = 640;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    let totalScore = 0;

    // --- Physics Engine Initialization ---
    const engine = Engine.create({
        // REVERSED GRAVITY!
        gravity: { y: -1.2 } 
    });
    const render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
            width: canvasWidth,
            height: canvasHeight,
            wireframes: false,
            background: '#4a5568'
        }
    });
    const runner = Runner.create();

    // --- Create Game Elements ---
    const world = engine.world;
    const pegs = [];
    const buckets = [];
    const balls = [];
    const releaseSlots = [];

    // Peg properties
    const pegRows = 10;
    const pegCols = 11;
    const pegSpacingY = 50;
    const pegSpacingX = 40;

    // Create pegs (shifted down to make space for top buckets)
    for (let row = 0; row < pegRows; row++) {
        const cols = pegCols + (row % 2 === 0 ? 0 : -1);
        const offsetX = (canvasWidth - (cols - 1) * pegSpacingX) / 2;
        for (let col = 0; col < cols; col++) {
            const x = offsetX + col * pegSpacingX;
            const y = 150 + row * pegSpacingY; // Start pegs lower on the screen
            const peg = Bodies.circle(x, y, 6, {
                isStatic: true,
                restitution: 0.6,
                friction: 0.1,
                render: { fillStyle: '#a0aec0' }
            });
            pegs.push(peg);
        }
    }

    // Bucket properties (now at the top)
    const numBuckets = 5;
    const bucketWidth = pegSpacingX * 1.8;
    const bucketHeight = 60;
    const bucketY = bucketHeight / 2 + 20; // Position buckets at the top
    const bucketPoints = [50, 20, 100, 20, 50]; // New point values for 5 buckets

    // Create buckets
    for (let i = 0; i < numBuckets; i++) {
        const x = (canvasWidth / numBuckets) * (i + 0.5);
        const bucket = Bodies.rectangle(x, bucketY, bucketWidth, bucketHeight, {
            isStatic: true,
            isSensor: true,
            render: { fillStyle: getBucketColor(bucketPoints[i]) },
            label: \`bucket-\${bucketPoints[i]}\`
        });
        buckets.push(bucket);

        // Add visual dividers for buckets
        if (i > 0) {
            const dividerX = x - (canvasWidth / numBuckets) / 2;
            const divider = Bodies.rectangle(dividerX, bucketY, 8, bucketHeight, {
                isStatic: true,
                render: { fillStyle: '#2d3748' }
            });
            World.add(world, divider);
        }
    }

    // Create Release Slots (Visual and Clickable)
    const numReleaseSlots = 5;
    const releaseSlotWidth = pegSpacingX * 1.5;
    const releaseSlotHeight = 20;
    const releaseSlotY = canvasHeight - releaseSlotHeight / 2 - 10;

    for (let i = 0; i < numReleaseSlots; i++) {
        const x = (canvasWidth / (numReleaseSlots + 1)) * (i + 1);
        const slot = Bodies.rectangle(x, releaseSlotY, releaseSlotWidth, releaseSlotHeight, {
            isStatic: true,
            render: { fillStyle: '#718096' },
            label: 'release-slot'
        });
        releaseSlots.push(slot);
    }

    // Walls and a ceiling sensor to catch missed balls
    const wallThickness = 20;
    const leftWall = Bodies.rectangle(-wallThickness/2, canvasHeight/2, wallThickness, canvasHeight, { isStatic: true, render: { visible: false } });
    const rightWall = Bodies.rectangle(canvasWidth + wallThickness/2, canvasHeight/2, wallThickness, canvasHeight, { isStatic: true, render: { visible: false } });
    const ceiling = Bodies.rectangle(canvasWidth / 2, -wallThickness / 2, canvasWidth, wallThickness, {
        isStatic: true,
        isSensor: true,
        label: 'ceiling'
    });

    // Add all bodies to the world
    World.add(world, [...pegs, ...buckets, ...releaseSlots, leftWall, rightWall, ceiling]);

    // --- Game Logic ---

    // Function to create a new ball (releases from the bottom)
    function createBall(xPosition) {
        const ballRadius = 10;
        const ball = Bodies.circle(xPosition, canvasHeight - 50, ballRadius, {
            restitution: 0.8,
            friction: 0.05,
            density: 0.001,
            render: { fillStyle: '#f87171' },
            label: 'ball'
        });
        balls.push(ball);
        World.add(world, ball);
    }

    // Function to get bucket color based on points
    function getBucketColor(points) {
        if (points >= 100) return '#48bb78'; // Green
        if (points >= 50) return '#4299e1'; // Blue
        if (points >= 20) return '#f6e05e'; // Yellow
        return '#f56565'; // Red
    }

    // --- Event Handlers ---

    // Listen for clicks on the canvas to release a ball
    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const mousePosition = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };

        // Find if a release slot was clicked
        const clickedSlots = Query.point(releaseSlots, mousePosition);

        if (clickedSlots.length > 0) {
            const clickedSlot = clickedSlots[0];
            createBall(clickedSlot.position.x);

            // Visual feedback for the click
            const originalColor = clickedSlot.render.fillStyle;
            clickedSlot.render.fillStyle = '#68D391'; // A bright green
            setTimeout(() => {
                clickedSlot.render.fillStyle = originalColor;
            }, 150);
        }
    });


    // Collision detection
    Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];
            const { bodyA, bodyB } = pair;
            
            let ball, other;
            if (bodyA.label === 'ball') {
                ball = bodyA;
                other = bodyB;
            } else if (bodyB.label === 'ball') {
                ball = bodyB;
                other = bodyA;
            } else {
                continue;
            }

            // Check if a ball has hit a bucket or the ceiling
            if (other.label.startsWith('bucket')) {
                handleBallInBucket(ball, other);
            } else if (other.label === 'ceiling') {
                removeBall(ball);
            }
        }
    });
    
    function removeBall(ball) {
        // Make the ball disappear after a short delay
        setTimeout(() => {
            World.remove(world, ball);
            const ballIndex = balls.indexOf(ball);
            if (ballIndex > -1) {
                balls.splice(ballIndex, 1);
            }
        }, 100);
    }

    function handleBallInBucket(ball, bucket) {
        if (!ball.isScored) {
            ball.isScored = true;
            
            const points = parseInt(bucket.label.split('-')[1]);
            totalScore += points;
            
            scoreElement.textContent = totalScore;
            lastWinElement.textContent = points;

            lastWinElement.parentElement.classList.add('animate-pulse');
            setTimeout(() => {
                 lastWinElement.parentElement.classList.remove('animate-pulse');
            }, 500);

            removeBall(ball);
        }
    }

    // --- Run the Game ---
    window.onload = function () {
        Render.run(render);
        Runner.run(runner, engine);

        // Add point labels to buckets
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 16px Poppins';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        function renderLabels() {
            buckets.forEach((bucket, i) => {
                const points = bucketPoints[i];
                const pos = bucket.position;
                ctx.fillText(points, pos.x, pos.y);
            });
            requestAnimationFrame(renderLabels);
        }
        renderLabels();
    }
<\/script>

</body>
</html>
`
        };

        const gameFrame = document.getElementById('game-frame');
        const tabs = document.getElementById('tabs');

        function loadGame(gameId) {
            const content = gameContent[gameId];
            if (content) {
                gameFrame.srcdoc = content;
            }
        }

        tabs.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                // Deactivate all buttons
                tabs.querySelectorAll('.tab-button').forEach(button => {
                    button.classList.remove('active');
                });
                // Activate the clicked button
                e.target.classList.add('active');
                
                const gameId = e.target.dataset.game;
                loadGame(gameId);
            }
        });

        // Load the default game on initial page load
        window.onload = () => {
            loadGame('taxPlinkov2');
        };
    </script>

</body>
</html>
